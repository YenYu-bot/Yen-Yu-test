<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>凸透鏡成像原理互動演示</title>
    <style>
        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        h2 {
            color: #333;
            margin-bottom: 10px;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        canvas {
            border: 1px solid #ddd;
            background: #fff;
            cursor: crosshair;
            border-radius: 8px;
        }
        #status-panel {
            margin-top: 15px;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 8px;
            border-left: 5px solid #007bff;
        }
        #status-panel h3 {
            margin: 0 0 10px 0;
            font-size: 1.1em;
            color: #007bff;
        }
        #status-panel p {
            margin: 5px 0;
            color: #555;
            font-size: 0.95em;
        }
        .highlight {
            font-weight: bold;
            color: #d9534f;
        }
        .instruction {
            color: #666;
            font-style: italic;
            margin-bottom: 15px;
            text-align: center;
        }
    </style>
</head>
<body>

    <h2>凸透鏡成像原理演示</h2>
    <p class="instruction">請用滑鼠拖曳左側的紅色箭頭（物體）來觀察成像變化。</p>

    <div class="container">
        <canvas id="lensCanvas" width="800" height="400"></canvas>
        <div id="status-panel">
            <h3>成像狀態分析</h3>
            <p id="position-status">物體位置：...</p>
            <p id="image-nature">成像性質：...</p>
        </div>
    </div>

<script>
    const canvas = document.getElementById('lensCanvas');
    const ctx = canvas.getContext('2d');
    const statusPosition = document.getElementById('position-status');
    const statusNature = document.getElementById('image-nature');

    // --- 配置參數 ---
    const W = canvas.width;
    const H = canvas.height;
    const centerX = W / 2; // 透鏡中心 X
    const centerY = H / 2; // 光軸 Y
    const f = 120;         // 焦距 (pixels)
    let objU = 200;        // 初始物距 (距離透鏡中心的距離)
    const objH = 80;       // 物體高度

    let isDragging = false;

    // --- 繪圖輔助函數 ---

    // 繪製線條
    function drawLine(x1, y1, x2, y2, color, width = 1, dashed = false) {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        if (dashed) {
            ctx.setLineDash([5, 5]);
        } else {
            ctx.setLineDash([]);
        }
        ctx.stroke();
        ctx.setLineDash([]); // 重置
    }

    // 繪製帶箭頭的線（用於物體和像）
    function drawArrow(x, yFrom, yTo, color, label) {
        const headlen = 10; // 箭頭長度
        const angle = Math.atan2(yTo - yFrom, 0);
        
        ctx.beginPath();
        ctx.moveTo(x, yFrom);
        ctx.lineTo(x, yTo);
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.stroke();

        // 箭頭頭部
        ctx.beginPath();
        ctx.moveTo(x, yTo);
        ctx.lineTo(x - headlen * Math.cos(angle - Math.PI / 6), yTo - headlen * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(x - headlen * Math.cos(angle + Math.PI / 6), yTo - headlen * Math.sin(angle + Math.PI / 6));
        ctx.lineTo(x, yTo);
        ctx.lineTo(x - headlen * Math.cos(angle - Math.PI / 6), yTo - headlen * Math.sin(angle - Math.PI / 6));
        ctx.fillStyle = color;
        ctx.fill();

        // 標籤
        ctx.fillStyle = color;
        ctx.font = "14px Arial";
        ctx.fillText(label, x - 15, yTo + (yTo > yFrom ? 20 : -10));
    }

    // 繪製點和標籤
    function drawPoint(x, y, label) {
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fillStyle = '#333';
        ctx.fill();
        ctx.font = "14px Arial";
        ctx.fillText(label, x - 5, y + 20);
    }

    // --- 核心繪圖邏輯 ---
    function draw() {
        ctx.clearRect(0, 0, W, H);

        // 1. 繪製環境 (光軸、透鏡、焦點)
        // 光軸
        drawLine(0, centerY, W, centerY, '#999');

        // 凸透鏡 (簡化為帶箭頭的線段)
        drawLine(centerX, centerY - 150, centerX, centerY + 150, '#007bff', 3);
        // 透鏡兩端的箭頭標記 (表示凸透鏡)
        ctx.beginPath(); ctx.moveTo(centerX-5, centerY-145); ctx.lineTo(centerX, centerY-155); ctx.lineTo(centerX+5, centerY-145); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(centerX-5, centerY+145); ctx.lineTo(centerX, centerY+155); ctx.lineTo(centerX+5, centerY+145); ctx.stroke();

        // 焦點 F1, F2, 和 2F 位置
        drawPoint(centerX - f, centerY, "F1");
        drawPoint(centerX + f, centerY, "F2");
        drawPoint(centerX - 2*f, centerY, "2F1");
        drawPoint(centerX + 2*f, centerY, "2F2");
        drawPoint(centerX, centerY, "O"); // 鏡心

        // 2. 計算成像位置和性質
        // 透鏡公式: 1/v = 1/f - 1/u
        // 注意：這裡 u 在左側，我們計算時取正值，公式裡用代數值需注意符號。
        // 這裡採用幾何光學慣例：物在左為正，像在右為正，焦距凸為正。
        let imgV = (f * objU) / (objU - f);
        let magnification = -imgV / objU;
        let imgH = objH * magnification;

        const objX = centerX - objU;
        const objTipY = centerY - objH;
        const imgX = centerX + imgV;
        const imgTipY = centerY + imgH; // 注意這裡加號，因為Y軸向下為正，而放大率負號已包含倒立信息

        // 3. 繪製物體 (紅色箭頭)
        drawArrow(objX, centerY, objTipY, '#d9534f', '物體');

        // 4. 繪製成像 (藍色箭頭) 和 光線追蹤
        const rayColor = "rgba(255, 165, 0, 0.6)"; // 橙色光線
        const virtualRayColor = "rgba(255, 165, 0, 0.3)"; // 虛像反向延長線

        if (objU === f) {
            // --- Case: u = f (不成像/無窮遠) ---
            updateStatus("物距 = 焦距 (u = f)", "不成像 (光線平行)");
            
            // 光線 1: 平行主軸 -> 過焦點 F2
            drawLine(objX, objTipY, centerX, objTipY, rayColor, 2);
            drawLine(centerX, objTipY, W, objTipY + (W-centerX)*(0 - objTipY)/(f), rayColor, 2);

            // 光線 2: 過鏡心 -> 直線傳播
            drawLine(objX, objTipY, W, objTipY + (W-objX)*(centerY - objTipY)/(centerX - objX), rayColor, 2);

        } else if (objU > f) {
            // --- Case: u > f (實像) ---
            drawArrow(imgX, centerY, imgTipY, '#0056b3', '實像');
            updateStatusBasedOnU(objU);

            // 光線 1: 平行主軸 -> 過焦點 F2 -> 到達成像點
            drawLine(objX, objTipY, centerX, objTipY, rayColor, 2);
            drawLine(centerX, objTipY, imgX, imgTipY, rayColor, 2);

            // 光線 2: 過鏡心 -> 直線傳播 -> 到達成像點
            drawLine(objX, objTipY, imgX, imgTipY, rayColor, 2);
             // 延伸出去一點
             drawLine(imgX, imgTipY, imgX + 50, imgTipY + 50 * (imgTipY-centerY)/(imgX-centerX), rayColor, 2);


            // 光線 3: 過焦點 F1 -> 平行主軸 -> 到達成像點
            drawLine(objX, objTipY, centerX, imgTipY, rayColor, 2); // 實際上是先過F1再到鏡子
            drawLine(centerX, imgTipY, imgX, imgTipY, rayColor, 2);

        } else {
            // --- Case: u < f (虛像) ---
            drawArrow(imgX, centerY, imgTipY, '#8A2BE2', '虛像'); // 紫色虛像
            updateStatus("物距 < 焦距 (u < f)", "正立、放大、虛像 (放大鏡原理)");

            // 光線 1: 平行主軸 -> 過焦點 F2 (向右發散)
            drawLine(objX, objTipY, centerX, objTipY, rayColor, 2);
            // 實際折射光
            drawLine(centerX, objTipY, W, objTipY + (W-centerX)*(centerY - objTipY)/(f), rayColor, 2);
            // 反向延長線 (虛線) 指向虛像
            drawLine(centerX, objTipY, imgX, imgTipY, virtualRayColor, 2, true);

            // 光線 2: 過鏡心 (向右發散)
            // 實際光
            drawLine(objX, objTipY, W, objTipY + (W-objX)*(centerY - objTipY)/(centerX - objX), rayColor, 2);
             // 反向延長線 (虛線) 指向虛像
            drawLine(centerX, centerY, imgX, imgTipY, virtualRayColor, 2, true);
        }
    }

    // --- 更新狀態面板文字 ---
    function updateStatus(posText, natureText) {
        statusPosition.innerHTML = `物體位置： <span class="highlight">${posText}</span>`;
        statusNature.innerHTML = `成像性質： <span class="highlight">${natureText}</span>`;
    }

    function updateStatusBasedOnU(u) {
        let pos, nature;
        if (u > 2 * f) {
            pos = "物距 > 2倍焦距 (u > 2f)";
            nature = "倒立、縮小、實像 (照相機原理)";
        } else if (Math.abs(u - 2 * f) < 2) { // 允許一點誤差
            pos = "物距 = 2倍焦距 (u = 2f)";
            nature = "倒立、等大、實像 (影印機原理)";
        } else if (u > f && u < 2 * f) {
            pos = "焦距 < 物距 < 2倍焦距 (f < u < 2f)";
            nature = "倒立、放大、實像 (投影機原理)";
        }
        updateStatus(pos, nature);
    }


    // --- 事件監聽 (拖曳互動) ---
    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const objX = centerX - objU;
        const objTipY = centerY - objH;

        // 檢查是否點擊在物體箭頭附近
        if (mouseX > objX - 20 && mouseX < objX + 20 &&
            mouseY > objTipY - 20 && mouseY < centerY + 10) {
            isDragging = true;
            canvas.style.cursor = 'grabbing';
        }
    });

    canvas.addEventListener('mousemove', (e) => {
        if (isDragging) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            
            // 更新物距 objU，並限制範圍
            // 限制不能超過左邊界，也不能太靠近鏡心(避免計算爆炸)
            let newU = centerX - mouseX;
            newU = Math.max(10, Math.min(newU, centerX - 20)); 
            
            objU = newU;
            draw();
        }
    });

    canvas.addEventListener('mouseup', () => {
        isDragging = false;
        canvas.style.cursor = 'crosshair';
    });
    
    // 初始繪製
    draw();

</script>
</body>
</html>

